/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/.pnpm/dabbjs@0.0.29/node_modules/dabbjs/dist/lib/dab.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/dabbjs@0.0.29/node_modules/dabbjs/dist/lib/dab.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   consts: () => (/* binding */ c),\n/* harmony export */   dP: () => (/* binding */ dP),\n/* harmony export */   defEnum: () => (/* binding */ defEnum),\n/* harmony export */   dfnd: () => (/* binding */ dfnd),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   fBool: () => (/* binding */ fBool),\n/* harmony export */   inherit: () => (/* binding */ inherit),\n/* harmony export */   isArr: () => (/* binding */ isArr),\n/* harmony export */   isBool: () => (/* binding */ isBool),\n/* harmony export */   isFn: () => (/* binding */ isFn),\n/* harmony export */   isInt: () => (/* binding */ isInt),\n/* harmony export */   isNum: () => (/* binding */ isNum),\n/* harmony export */   isNumeric: () => (/* binding */ isNumeric),\n/* harmony export */   isObj: () => (/* binding */ isObj),\n/* harmony export */   isStr: () => (/* binding */ isStr),\n/* harmony export */   obj: () => (/* binding */ obj),\n/* harmony export */   pInt: () => (/* binding */ pInt),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   pojo: () => (/* binding */ pojo),\n/* harmony export */   round: () => (/* binding */ round),\n/* harmony export */   splat: () => (/* binding */ splat),\n/* harmony export */   toBool: () => (/* binding */ toBool),\n/* harmony export */   ts: () => (/* binding */ ts),\n/* harmony export */   typeOf: () => (/* binding */ typeOf)\n/* harmony export */ });\n//still in progress...\nconst c = {\n    s: \"string\",\n    o: \"object\",\n    b: \"boolean\",\n    i: \"integer\",\n    n: \"number\",\n    a: \"array\",\n    fn: \"function\",\n    sp: \"super\",\n    c: \"color\",\n    t: \"type\",\n    d: \"defaut\",\n    u: \"undefined\",\n    v: \"value\",\n    svgNs: \"http://www.w3.org/2000/svg\"\n};\n/**\n * constant object created so {@link ts}(t: any) doesn't have to create an object in each call\n */\nconst OBJ = {};\n\n/**\n * type of argument\n *\n * @param t any\n * @returns '[object Undefined | Null | Number | String | Boolean | Array | Object | Function, Date, RegExp]'\n */\nconst ts = (t) => OBJ.toString.call(t);\n/**\n * returned values: undefined, null, number, string, boolean, array, object, function, date, regexp\n * @param o any\n */\nconst typeOf = (o) => ts(o).slice(8, -1).toLowerCase();\n/**\n * returns true if argument is an string\n * @param f any\n * @returns\n */\nconst isStr = (s) => typeof s === c.s;\n/**\n * returns true if argument is a function\n * @param f any\n * @returns\n */\nconst isFn = (f) => typeof f === c.fn;\n/**\n * it can be extended later object {}\n * @param s any\n * @returns `true` for undefined, void 0, 0, false, \"\", \"  \", []\n */\nconst empty = (s) => {\n    const t_s = typeof s;\n    return t_s == c.u || !s || (t_s === c.s && s.match(/^ *$/) !== null) || (Array.isArray(s) && !s.length);\n};\n/**\n * returns true if argument is defined,\n *\n * undefined === void 0\n *\n * @param t any\n */\nconst dfnd = (t) => t !== void 0 && t !== null;\n/**\n * returns true if argument is an array\n * @param f any\n * @returns\n */\nconst isArr = (t) => Array.isArray(t); // typeOf(t) === c.a;\n/**\n * returns true if n is number\n * @param n value\n *\n * - \"1\" returns false\n * - NaN returns true\n */\nconst isNum = (n) => typeof n === c.n;\n/**\n * returns true if n is numeric\n * @param n\n *\n * - \"1\" returns true\n * - NaN returns false\n */\nconst isNumeric = (n) => isNaN(n) ? !1 : (n = parseInt(n), (0 | n) === n);\n//return (typeof x === dab.n) && (x % 1 === 0);\nconst isInt = (n) => (parseFloat(n) == parseInt(n)) && !isNaN(n);\n//http://speakingjs.com/es5/ch11.html#converting_to_integer\n/**\n * parse a number according to a radix\n * @param s string value\n * @param radix convertion radix\n *\n * - \"0101001\" => 2\t\tbinary\n * - \"0xFF\"\t=> 255 hexadecimal\n * - \"123\" => 123\n */\nconst pInt = (s, radix) => parseInt(s, radix);\n/**\n * clamps a value inside a range min..max\n * @param v value\n * @param min minim\n * @param max maximum\n */\nconst clamp = (v, min, max) => (v <= min) ? min : (v >= max) ? max : v;\n/**\n * rounds a number to a decimal\n * @param v float value\n * @param decimals valid decimals\n *\n * - (123.5678, 1) => 123.6\n * - (123.5678, 0) => 124\n * - (123.5678, -1) => NaN\n */\nconst round = (v, decimals) => {\n    //https://expertcodeblog.wordpress.com/2018/02/12/typescript-javascript-round-number-by-decimal-pecision/\n    return (decimals = decimals | 0, Number(Math.round(Number(v + \"e\" + decimals)) + \"e-\" + decimals));\n}; //force toArray\n/**\n * converts a `defined` argument value to an array\n * @param o any\n * @returns\n */\nconst splat = (o) => isArr(o) ? o : (dfnd(o) ? [o] : []);\n/**\n * makes a child inherit or descend from its parent\n * @param parent parent\n * @param child child\n */\nconst inherit = (parent, child) => {\n    child.prototype = Object.create(parent.prototype);\n    child.prototype.constructor = child;\n};\n/**\n * returns true if argument is an object\n * @param t any\n */\nconst isObj = (t) => ts(t) == '[object Object]';\n/**\n * plainObj   Plain Old JavaScript Object (POJO) {}\n * @param arg args\n */\nconst pojo = (arg) => {\n    if (arg == null || typeof arg !== 'object') {\n        return false;\n    }\n    const proto = Object.getPrototypeOf(arg);\n    // Prototype may be null if you used `Object.create(null)`\n    // Checking `proto`'s constructor is safe because `getPrototypeOf()`\n    // explicitly crosses the boundary from object data to object metadata\n    return !proto || proto.constructor.name === 'Object';\n    //Object.getPrototypeOf([]).constructor.name == \"Array\"\n    //Object.getPrototypeOf({}).constructor.name == \"Object\"\n    //Object.getPrototypeOf(Object.create(null)) == null\n};\n/**\n * deep copy\n * @param o any\n */\nconst obj = (o) => {\n    if (!pojo(o)) {\n        return o;\n    }\n    let result = Object.create(null);\n    for (let k in o)\n        if (!o.hasOwnProperty || o.hasOwnProperty(k)) {\n            let prop = o[k];\n            result[k] = pojo(prop) ? obj(prop) : prop;\n        }\n    return result;\n};\n/**\n * JSON stringify & parse cloner\n * @param o any\n */\nconst clone = (o) => JSON.parse(JSON.stringify(o));\nconst defEnum = (e) => {\n    for (let key in e) { //let item = e[key];\n        e[e[key]] = key;\n    }\n    return e;\n};\n/**\n * defines a new object property\n * @param obj object\n * @param propName property name\n * @param attrs attributes\n */\nconst dP = (obj, propName, attrs) => Object.defineProperty(obj, propName, attrs);\nconst a = {\n    'TRUE': true,\n    'True': true,\n    'true': true,\n    '1': true,\n    'FALSE': false,\n    'False': false,\n    'false': false,\n    '0': false\n};\n/**\n * return true if value it's true or false, undefined if not valid\n * @param val any\n *\n * value can be:\n * - TRUE\n * - True\n * - true\n * - FALSE\n * - False\n * - false\n * - 1\n * - 0\n */\nconst toBool = (val) => a[val];\n/**\n * return true if value is a valid boolean\n * @param val any\n *\n * valid values are:\n * - TRUE\n * - True\n * - true\n * - FALSE\n * - False\n * - false\n * - 1\n * - 0\n */\nconst isBool = (val) => a[val] != undefined;\n/**\n * converts a value to boolean, and undefined are forced to boolean\n * @param val value\n * @param forcedUndefined forced undefined values, default is \"false\"\n */\nconst fBool = (val, forcedUndefined) => a[val] || !!forcedUndefined;\n/**\n * parses an string and returns an array of parsed number values\n * @param s string in the form \"n0, n1, n2, n3, n(n)\"\n * @param l amount of valid numbers to parse\n * @returns number array if valid, undefined otherwise\n */\nconst parse = (s, l) => {\n    let n, nans = false, numbers = s.split(',').map(str => (n = parseFloat(str), isNaN(n) && (nans = true), n));\n    return (nans || numbers.length != l) ? void 0 : numbers;\n};\n\n\n//# sourceURL=webpack://adtjs/./node_modules/.pnpm/dabbjs@0.0.29/node_modules/dabbjs/dist/lib/dab.js?\n}");

/***/ }),

/***/ "./node_modules/.pnpm/dabbjs@0.0.29/node_modules/dabbjs/dist/lib/dom.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/dabbjs@0.0.29/node_modules/dabbjs/dist/lib/dom.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DOMTemplates: () => (/* binding */ DOMTemplates),\n/* harmony export */   aChld: () => (/* binding */ aChld),\n/* harmony export */   aCl: () => (/* binding */ aCl),\n/* harmony export */   aClx: () => (/* binding */ aClx),\n/* harmony export */   aEL: () => (/* binding */ aEL),\n/* harmony export */   attr: () => (/* binding */ attr),\n/* harmony export */   basePath: () => (/* binding */ basePath),\n/* harmony export */   css: () => (/* binding */ css),\n/* harmony export */   daEl: () => (/* binding */ daEl),\n/* harmony export */   decodeHTMLEntities: () => (/* binding */ decodeHTMLEntities),\n/* harmony export */   drEL: () => (/* binding */ drEL),\n/* harmony export */   encodeHTMLEntities: () => (/* binding */ encodeHTMLEntities),\n/* harmony export */   escapeChars: () => (/* binding */ escapeChars),\n/* harmony export */   gEId: () => (/* binding */ gEId),\n/* harmony export */   hCl: () => (/* binding */ hCl),\n/* harmony export */   html: () => (/* binding */ html),\n/* harmony export */   isDOM: () => (/* binding */ isDOM),\n/* harmony export */   qS: () => (/* binding */ qS),\n/* harmony export */   qSA: () => (/* binding */ qSA),\n/* harmony export */   rCl: () => (/* binding */ rCl),\n/* harmony export */   rEL: () => (/* binding */ rEL),\n/* harmony export */   ready: () => (/* binding */ ready),\n/* harmony export */   registerCustomElement: () => (/* binding */ registerCustomElement),\n/* harmony export */   svg: () => (/* binding */ svg),\n/* harmony export */   svgStyles: () => (/* binding */ svgStyles),\n/* harmony export */   tCl: () => (/* binding */ tCl),\n/* harmony export */   tag: () => (/* binding */ tag)\n/* harmony export */ });\n/* harmony import */ var _dab__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dab */ \"./node_modules/.pnpm/dabbjs@0.0.29/node_modules/dabbjs/dist/lib/dab.js\");\n\n/**\n * returns true if an element if an HTML or SVG DOM element\n * @param e {any} an element\n */\nconst isDOM = (e) => e instanceof HTMLElement; // || e instanceof Document;\n/**\n * css(el, { background: 'green', display: 'none', 'border-radius': '5px' });\n * @param el HTMLElement\n * @param styles object of styles\n */\nconst css = (el, styles) => {\n    if ((0,_dab__WEBPACK_IMPORTED_MODULE_0__.isStr)(styles))\n        return el.style[styles];\n    else {\n        Object.assign(el.style, styles);\n        // for (let prop in styles)\n        // \tel.style[prop] = styles[prop];\n        return el;\n    }\n};\n/**\n * get/set html element attribute\n * @param el HTML element\n * @param attrs string to get it's attribute, or an object with attributes to set\n * @param value when defined\n *\n * should be attr(el: HTMLElement, attr: { [id: string]: any } | string, value?: string)\n *\n * when attr is an object, it sets all attributes in the object\n *\n * when value is undefined, it returns the attribute value if any\n * when value is an string\n */\nconst attr = function (el, attrs, value) {\n    if (typeof attrs == \"string\") {\n        if (value) {\n            //set single attr and return HTMLElement\n            el.setAttribute(attrs, value);\n        }\n        else {\n            //return HTMLElement single attribute value\n            return el.getAttribute(attrs);\n        }\n    }\n    else {\n        //assign object of attributes to HTMLElement\n        for (let attr in attrs)\n            el.setAttribute(attr, attrs[attr]);\n    }\n    return el;\n};\n/**\n * adds an event listener to an element\n * @param el element\n * @param type event name\n * @param fn listener function\n * @param b boolean | AddEventListenerOptions | undefined\n */\nconst aEL = (el, type, fn, b) => el.addEventListener(type, fn, b);\n/**\n * removes an event listener from an element\n * @param el element\n * @param type event name\n * @param fn\n * @param b\n */\nconst rEL = (el, type, fn, b) => el.removeEventListener(type, fn, b);\n/**\n * adds an event listener to the document\n * @param type event name\n * @param fn listener function\n * @param b boolean | AddEventListenerOptions | undefined\n */\nconst daEl = (type, fn, b) => document.addEventListener(type, fn, b);\n/**\n * removes an event listener from the document\n * @param el element\n * @param type event name\n * @param fn\n * @param b\n */\nconst drEL = (type, fn, b) => document.removeEventListener(type, fn, b);\n/**\n * appends a child element to it's new parent\n * @param parent parent element\n * @param child child element\n */\nconst aChld = (parent, child) => parent.appendChild(child);\n/**\n * test for class\n * @param el Element\n * @param className className cannot contain spaces\n * @returns true if present, false otherwise\n */\nconst hCl = (el, className) => el.classList.contains(className);\n/**\n * adds a class to an Element\n * @param el Element\n * @param className className cannot contain spaces\n */\nconst aCl = (el, className) => el.classList.add(className);\n/**\n * removes a class from an Element\n * @param el Element\n * @param className className cannot contain spaces\n */\nconst rCl = (el, className) => el.classList.remove(className);\n/**\n * toggles a class from an Element\n * @param el Element\n * @param className className cannot contain spaces\n * @param force undefined is toggle, true is add, false is remove\n * @returns true if present, false if not\n */\nconst tCl = (el, className, force) => el.classList.toggle(className, force);\n/**\n * add class safe\n * @param el HTMLElement\n * @param className class names separated by space\n */\nconst aClx = (el, className) => {\n    el.classList.add(...(className || \"\").split(' ').filter((v) => !(0,_dab__WEBPACK_IMPORTED_MODULE_0__.empty)(v)));\n    return el;\n};\n/**\n * calls a function when DOM is ready\n * @param fn function to be called\n */\nconst ready = (fn) => {\n    if (!(0,_dab__WEBPACK_IMPORTED_MODULE_0__.isFn)(fn)) {\n        return !1;\n    }\n    if (document.readyState != \"loading\")\n        return (fn(), !0);\n    else if (document[\"addEventListener\"])\n        aEL(document, \"DOMContentLoaded\", fn, false);\n    else\n        document.attachEvent(\"onreadystatechange\", () => {\n            if (document.readyState == \"complete\")\n                fn();\n        });\n    return !0;\n};\n/**\n * document.querySelector shortcut\n * @param selectors query string\n * @param elem HTMLElement or document if undefined\n */\nconst qS = (selectors, elem) => (elem || document).querySelector(selectors);\n/**\n * document.querySelectorAll shortcut\n * @param selectors query string\n * @param elem HTMLElement or document if undefined\n */\nconst qSA = (selectors, elem) => Array.from((elem || document).querySelectorAll(selectors));\n/**\n * document.getElementById shortcut\n * @param s #id\n */\nconst gEId = (id) => document.getElementById(id);\n/**\n * extracts a base-name from page metadata\n */\nconst basePath = () => {\n    let meta = qS('meta[name=\"base\"]');\n    return meta ? meta.getAttribute('content') : \"\";\n};\n/**\n * creates an SVG element by tag name\n * @param tagName tag name\n * @param id optional name\n * @param nsAttrs attributes\n */\nconst tag = (tagName, id, nsAttrs) => (id && (nsAttrs.id = id),\n    attr(document.createElementNS(_dab__WEBPACK_IMPORTED_MODULE_0__.consts.svgNs, tagName), nsAttrs));\n/**\n* creates an SVG element by an string\n* @param html html string representation\n*/\nconst svg = (html) => {\n    let template = document.createElementNS(_dab__WEBPACK_IMPORTED_MODULE_0__.consts.svgNs, \"template\");\n    template.innerHTML = html;\n    return template.children[0];\n};\n/**\n* creates an HTML element by an string\n* @param html html string representation\n*/\nconst html = (html) => {\n    let template = document.createElement(\"template\");\n    template.innerHTML = html;\n    return template.content.firstChild;\n};\nconst registerCustomElement = (name, constructor) => {\n    //https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements\n    if (customElements.get(name))\n        return false;\n    customElements.define(name, constructor);\n    return true;\n};\n//If you use a \"<div/>\" tag, it will strip out all the html.\n//If you use a \"<textarea/>\" tag, it will preserve the html tags.\n/**\n *\n * @param text\n * @returns\n */\nconst decodeHTMLEntities = (text) => {\n    let textArea = document.createElement('textarea');\n    textArea.innerHTML = text;\n    return textArea.value;\n};\n/**\n *\n * @param text\n * @returns\n */\nconst encodeHTMLEntities = (text) => {\n    let textArea = document.createElement('textarea');\n    textArea.innerText = text;\n    return textArea.innerHTML;\n};\n/**\n *\n * @param str\n * @returns\n */\nconst escapeChars = (str) => {\n    let div = html(str);\n    div.innerText = str;\n    return div.innerHTML;\n};\n/**\n * saves CSS in Document DOM inside SVG element styles\n * @param dom\n * @returns\n */\nconst svgStyles = (dom) => {\n    let used = \"\";\n    let sheets = document.styleSheets;\n    for (let i = 0; i < sheets.length; i++) {\n        let rules = sheets[i].cssRules;\n        for (let j = 0; j < rules.length; j++) {\n            let rule = rules[j];\n            if (typeof (rule.style) != \"undefined\") {\n                let elems = dom.querySelectorAll(rule.selectorText);\n                if (elems.length > 0) {\n                    used += rule.selectorText + \" { \" + rule.style.cssText + \" }\\n\";\n                }\n            }\n        }\n    }\n    let s = document.createElement('style');\n    s.setAttribute('type', 'text/css');\n    s.innerHTML = \"<![CDATA[\\n\" + used + \"\\n]]>\";\n    let defs = document.createElement('defs');\n    defs.appendChild(s);\n    dom.insertBefore(defs, dom.firstChild);\n    return dom;\n};\n/**\n * retrieves all DOM script templates\n *\n * script with attribute data-tmpl=\"id\" are returned as an object with [id] as key.\n *\n * it removes any CDATA, LF, NL, Tabs from result\n */\nconst DOMTemplates = () => {\n    let templates = {};\n    qSA('script[data-tmpl]').forEach((scr) => {\n        let id = scr.getAttribute('data-tmpl'), src = scr.innerHTML.replace(\"<![CDATA[\", \"\").replace(\"]]>\", \"\").replace(/[\\r\\n\\t]/g, \"\").trim();\n        templates[id] = src;\n    });\n    return templates;\n};\n\n\n//# sourceURL=webpack://adtjs/./node_modules/.pnpm/dabbjs@0.0.29/node_modules/dabbjs/dist/lib/dom.js?\n}");

/***/ }),

/***/ "./node_modules/.pnpm/dabbjs@0.0.29/node_modules/dabbjs/dist/lib/strings.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/dabbjs@0.0.29/node_modules/dabbjs/dist/lib/strings.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   camel: () => (/* binding */ camel),\n/* harmony export */   cssCamel: () => (/* binding */ cssCamel),\n/* harmony export */   cssUncamel: () => (/* binding */ cssUncamel),\n/* harmony export */   fillChar: () => (/* binding */ fillChar),\n/* harmony export */   formatNumber: () => (/* binding */ formatNumber),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   padStr: () => (/* binding */ padStr)\n/* harmony export */ });\n/**\n * used for string & numbers\n * @param t string\n * @param e amount\n * @param ch pad char\n */\nconst pad = (t, e, ch) => new Array(Math.max(0, (e || 2) + 1 - String(t).length)).join(ch || '0') + t;\n/**\n*\n* @param ch char|string to fill\n* @param len repeat count, must be equal or greater than zero\n*/\nconst fillChar = (ch, len) => new Array(len + 1).join(ch);\n/**\n* left pads an string\n* @param s string to padd\n* @param width max amount of final string, if less, same string is returned\n*/\nconst padStr = (s, width) => new Array(Math.max(0, width - s.length + 1)).join(' ') + s;\n/**\n* pad left number\n* @param n number to convert to string\n* @param width max width, if less, number to string is returned\n*/\nconst formatNumber = (n, width) => padStr(n + \"\", width);\n/**\n * converts a web css property to camel case\n * @param str font-size  -webkit-box-shadow\n * @@returns fontSize  WebkitBoxShadow\n */\nconst cssCamel = (str) => str.replace(/-([a-z])/gi, (_match, group) => group.toUpperCase());\n/**\n * removes camel of a web css property\n * @param str fontSize  WebkitBoxShadow\n * @returns font-size  -webkit-box-shadow\n */\nconst cssUncamel = (str) => str.replace(/([A-Z])/g, (_match, group) => '-' + group.toLowerCase());\n/**\n * converts an string to camel case\n * @param str string\n *\n * - width => Width\n * - width height => Width Height\n */\nconst camel = (str) => str.replace(/([a-z])(\\w*)/gi, (_match, letter, rest) => letter.toUpperCase() + rest);\n\n\n//# sourceURL=webpack://adtjs/./node_modules/.pnpm/dabbjs@0.0.29/node_modules/dabbjs/dist/lib/strings.js?\n}");

/***/ }),

/***/ "./src/lib/BTree.ts":
/*!**************************!*\
  !*** ./src/lib/BTree.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BTree: () => (/* binding */ BTree),\n/* harmony export */   BTreeNode: () => (/* binding */ BTreeNode),\n/* harmony export */   SearchBTreeTraverse: () => (/* binding */ SearchBTreeTraverse)\n/* harmony export */ });\n/* harmony import */ var _Tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tree */ \"./src/lib/Tree.ts\");\n/* harmony import */ var _Stack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Stack */ \"./src/lib/Stack.ts\");\n\n\nclass BTreeNode extends _Tree__WEBPACK_IMPORTED_MODULE_0__.ValueNode {\n    get isLeaf() { return !this.left && !this.right; }\n    get children() {\n        return [this.left, this.right].filter(item => !!item);\n    }\n    constructor(value, left, right) {\n        super(value);\n        this.left = left;\n        this.right = right;\n    }\n}\nvar SearchBTreeTraverse;\n(function (SearchBTreeTraverse) {\n    SearchBTreeTraverse[SearchBTreeTraverse[\"Root\"] = 0] = \"Root\";\n    SearchBTreeTraverse[SearchBTreeTraverse[\"Left\"] = 1] = \"Left\";\n    SearchBTreeTraverse[SearchBTreeTraverse[\"Right\"] = 2] = \"Right\";\n})(SearchBTreeTraverse || (SearchBTreeTraverse = {}));\nclass BTree extends _Tree__WEBPACK_IMPORTED_MODULE_0__.BaseTree {\n    get size() { return this.__size; }\n    constructor(root, comparer) {\n        super(comparer);\n        this.root = root;\n        this.__size = 0;\n        if (this.root != undefined) {\n            for (let n of this.preOrderEnumerator())\n                this.__size++;\n        }\n    }\n    find(value) {\n        let key = this.findKey(value);\n        //key.comp == 0 && key.node != undefined has a valid found node\n        return key.comp == 0 ? key.node : undefined;\n    }\n    //(LNR)\n    *inOrderEnumerator(node) {\n        let stack = new _Stack__WEBPACK_IMPORTED_MODULE_1__.Stack(), count = 0, n = node || this.root;\n        while (!stack.empty || n != undefined) {\n            if (n != undefined) {\n                stack.push(n);\n                n = n.left;\n            }\n            else {\n                n = stack.pop();\n                count++;\n                yield n;\n                n = n.right;\n            }\n        }\n        return count;\n    }\n    *postOrderEnumerator(node) {\n        let stack = new _Stack__WEBPACK_IMPORTED_MODULE_1__.Stack(), n = node || this.root, lastNodeVisited, count = 0;\n        while (!stack.empty || n != undefined) {\n            if (n != undefined) {\n                stack.push(n);\n                n = n.left;\n            }\n            else {\n                let peekNode = stack.peek();\n                // if right child exists and traversing node from left child, then move right\n                if (peekNode.right != undefined && lastNodeVisited != peekNode.right)\n                    n = peekNode.right;\n                else {\n                    count++;\n                    yield peekNode;\n                    lastNodeVisited = stack.pop();\n                }\n            }\n        }\n        return count;\n    }\n    newNode(value) {\n        return new BTreeNode(value);\n    }\n    min(node) {\n        if (node)\n            while (node.left != undefined)\n                node = node.left;\n        return node;\n    }\n    max(node) {\n        if (node)\n            while (node.right != undefined)\n                node = node.right;\n        return node;\n    }\n    findKey(value) {\n        let prevComp = 0, parent = void 0, node = this.root;\n        while (node != undefined) {\n            let comp = this.comparer(value, node.value);\n            if (comp == 0) {\n                return {\n                    node: node,\n                    parent: parent,\n                    prevComp: prevComp,\n                    comp: 0\n                };\n            }\n            else if (comp < 0) {\n                if (node.left != undefined) {\n                    parent = node;\n                    prevComp = comp;\n                }\n                node = node.left;\n            }\n            else {\n                if (node.right != undefined) {\n                    parent = node;\n                    prevComp = comp;\n                }\n                node = node.right;\n            }\n        }\n        return { node: void 0, parent: void 0, prevComp: 0, comp: 0 };\n    }\n    insert(value) {\n        let key = this.findKey(value), node = getChild(key.parent, key.prevComp), child = this.newNode(value);\n        return (node != undefined) && (setChild(node, child, key.comp), this.__size++, true);\n    }\n    delete(value) {\n        let key = this.findKey(value);\n        if (!(key.comp == 0 && key.node != undefined)) {\n            return false;\n        }\n        if (key.node.isLeaf) {\n            setChild(key.parent, void 0, key.prevComp);\n        }\n        else if (key.node.left == undefined || key.node.right == undefined) {\n            setChild(key.parent, getChild(key.node, key.node.left == undefined ? 1 : -1), key.prevComp);\n        }\n        else {\n            let p = void 0, n = key.node.left, comp = n.right == undefined ? -1 : 1;\n            while (n.right != undefined) {\n                p = n;\n                n = n.right;\n            }\n            key.node.value = n.value;\n            if (p == undefined)\n                p = key.node;\n            setChild(p, n.left, comp);\n        }\n        this.__size--;\n        return true;\n    }\n    insertRange(values) {\n        let array = [];\n        values.forEach(value => array.push(this.insert(value)));\n        return array;\n    }\n    deleteRange(values) {\n        let array = [];\n        values.forEach(value => array.push(this.delete(value)));\n        return array;\n    }\n}\nfunction getChild(parent, comp) {\n    return (parent == undefined) ? undefined : (comp < 0 ? parent.left : parent.right);\n}\nfunction setChild(parent, node, comp) {\n    (parent != undefined) && (comp < 0 ? parent.left = node : parent.right = node);\n}\n\n\n//# sourceURL=webpack://adtjs/./src/lib/BTree.ts?\n}");

/***/ }),

/***/ "./src/lib/Queue.ts":
/*!**************************!*\
  !*** ./src/lib/Queue.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Queue: () => (/* binding */ Queue)\n/* harmony export */ });\n/* harmony import */ var _Stack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Stack */ \"./src/lib/Stack.ts\");\n\nclass Queue extends _Stack__WEBPACK_IMPORTED_MODULE_0__.Stack {\n    dequeue() { return this.pop(); }\n    enqueue(t) { return this.n.unshift(t); }\n    peek() { return this.n[0]; }\n    peekback() { return super.peek(); }\n    static from(initialData = []) {\n        const q = new Queue();\n        q.n.unshift(...initialData);\n        return q;\n    }\n}\n\n\n//# sourceURL=webpack://adtjs/./src/lib/Queue.ts?\n}");

/***/ }),

/***/ "./src/lib/RedBlackTree.ts":
/*!*********************************!*\
  !*** ./src/lib/RedBlackTree.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RedBlackEnum: () => (/* binding */ RedBlackEnum),\n/* harmony export */   RedBlackTree: () => (/* binding */ RedBlackTree),\n/* harmony export */   RedBlackTreeNode: () => (/* binding */ RedBlackTreeNode)\n/* harmony export */ });\n/* harmony import */ var _BTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BTree */ \"./src/lib/BTree.ts\");\n/* harmony import */ var _Stack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Stack */ \"./src/lib/Stack.ts\");\n\n\nvar RedBlackEnum;\n(function (RedBlackEnum) {\n    RedBlackEnum[RedBlackEnum[\"red\"] = 0] = \"red\";\n    RedBlackEnum[RedBlackEnum[\"black\"] = 1] = \"black\";\n})(RedBlackEnum || (RedBlackEnum = {}));\nclass RedBlackTreeNode extends _BTree__WEBPACK_IMPORTED_MODULE_0__.BTreeNode {\n    constructor(value) {\n        super(value);\n        this.color = RedBlackEnum.red;\n    }\n}\nclass RedBlackTree extends _BTree__WEBPACK_IMPORTED_MODULE_0__.BTree {\n    constructor(comparer) {\n        super(undefined, comparer);\n    }\n    insert(value) {\n        let stack = new _Stack__WEBPACK_IMPORTED_MODULE_1__.Stack(), parent = void 0, node = this.root, comp = 0;\n        if (node == undefined) {\n            this.root = node = newNode(value);\n            node.color = RedBlackEnum.black;\n            this.__size++;\n            return true;\n        }\n        while (node != undefined) {\n            parent = node;\n            comp = this.comparer(value, node.value);\n            if (comp == 0)\n                return false;\n            else {\n                if (comp < 0)\n                    node = node.left;\n                else\n                    node = node.right;\n                stack.push(parent);\n            }\n        }\n        node = newNode(value);\n        setChild(parent, node, comp);\n        balanceAfterInsert(this, node, stack);\n        this.__size++;\n        return true;\n    }\n    delete(value) {\n        let found = false, comp = 0, stack = new _Stack__WEBPACK_IMPORTED_MODULE_1__.Stack(), parent = void 0, node = this.root, yIsNode, x, ycomp = 0, yParent, y;\n        while (node != undefined && !found) {\n            let nextComp = this.comparer(value, node.value);\n            if (nextComp == 0)\n                found = true;\n            else {\n                parent = node;\n                if (nextComp < 0) {\n                    node = node.left;\n                }\n                else {\n                    node = node.right;\n                }\n                stack.push(parent);\n                comp = nextComp;\n            }\n        }\n        if (!found)\n            return false;\n        // \"node\" to be deleted: \n        //\t  is a leaf with no children\n        //\t  has one child\n        //\t  has two children\n        // if \"node\" is red, the red black properties still hold.\n        // if \"node\" is black, the tree needs rebalancing and/or recolouring\n        if (node.left == undefined || node.right == undefined) {\n            //node is leaf or has at least one empty child\n            y = node;\n            yParent = parent;\n            yIsNode = true;\n        }\n        else {\n            //node has 2 children\n            //replacement node is the leftmost node greater than \"node\"\n            stack.push(node);\n            y = node.right;\n            yParent = node;\n            yIsNode = false;\n            while (y.left != undefined) {\n                stack.push(y);\n                yParent = y;\n                y = y.left;\n            }\n        }\n        //y has the replacement node here, it's \"value\" content will be copied to \"node\"\n        //x is y's only child, it'll be linked to y's parent\n        if (y.left != undefined)\n            x = y.left;\n        else\n            x = y.right;\n        // replace x's parent with y's parent and link x to proper subtree in parent, this removes y from tree\n        if (yParent != undefined) {\n            setChild(yParent, x, ycomp = this.comparer(y.value, yParent.value));\n        }\n        else {\n            this.root = x;\n            (x != undefined) && (x.color = RedBlackEnum.black);\n            this.__size--;\n            return true;\n        }\n        !yIsNode && (node.value = y.value);\n        if (y.color == RedBlackEnum.black) {\n            // x may be undefined\n            balanceAfterDelete(this, x, stack, ycomp);\n        }\n        this.__size--;\n        return true;\n    }\n}\nconst siblingComparer = (comp) => comp > 0 ? -1 : 1;\nfunction setChild(parent, node, comp) {\n    if (comp < 0)\n        parent.left = node;\n    else\n        parent.right = node;\n}\nfunction getChild(parent, comp) {\n    return (comp < 0 ? parent.left : parent.right);\n}\nfunction newNode(value) {\n    return new RedBlackTreeNode(value);\n}\nfunction getColor(node) {\n    return node == undefined ?\n        RedBlackEnum.black :\n        node.color;\n}\nfunction rotateLeft(x, tree, stack, pushParent) {\n    let p = stack.peek(), y = x.right;\n    x.right = y.left;\n    y.left = x;\n    pushParent && stack.push(y);\n    if (p != undefined)\n        setChild(p, y, tree.comparer(y.value, p.value));\n    else\n        tree.root = y;\n}\nfunction rotateRight(x, tree, stack, pushParent) {\n    let p = stack.peek(), y = x.left;\n    x.left = y.right;\n    y.right = x;\n    pushParent && stack.push(y);\n    if (p != undefined)\n        setChild(p, y, tree.comparer(y.value, p.value));\n    else\n        tree.root = y;\n}\nfunction balanceAfterInsert(tree, x, stack) {\n    let t, g, p, y = x.left, comp = 0;\n    while (stack.count >= 2 && (p = stack.pop()).color == RedBlackEnum.red) {\n        //parent is RED\n        g = stack.peek();\n        comp = tree.comparer(p.value, g.value);\n        //get x's parent uncle y\n        if (comp < 0)\n            y = g.right;\n        else\n            y = g.left;\n        if (y != undefined && y.color == RedBlackEnum.red) {\n            //uncle is RED, change x's parent and uncle to black\n            p.color = RedBlackEnum.black;\n            y.color = RedBlackEnum.black;\n            // grandparent must be red. Why? Every red node that is not \n            // a leaf has only black children\n            g.color = RedBlackEnum.red;\n            stack.pop();\n            x = g;\n        }\n        else {\n            //uncle is BLACK\n            if (comp < 0) {\n                if (tree.comparer(x.value, p.value) > 0) {\n                    // x > p, rotate left, make x a left child\n                    rotateLeft(p, tree, stack, false);\n                    //this's faster than ES6 array destructuring\n                    t = x;\n                    x = p;\n                    p = t;\n                }\n                // x < p\n                p.color = RedBlackEnum.black;\n                g.color = RedBlackEnum.red;\n                stack.pop();\n                rotateRight(g, tree, stack, true);\n            }\n            else {\n                if (tree.comparer(x.value, p.value) < 0) {\n                    // x < p, rotate right, make x a right child\n                    rotateRight(p, tree, stack, false);\n                    //this's faster than ES6 array destructuring\n                    t = x;\n                    x = p;\n                    p = t;\n                }\n                // x > p\n                p.color = RedBlackEnum.black;\n                g.color = RedBlackEnum.red;\n                stack.pop();\n                rotateLeft(g, tree, stack, true);\n            }\n        }\n    }\n    tree.root.color = RedBlackEnum.black;\n}\nfunction balanceAfterDelete(tree, x, stack, comp) {\n    let parent, y;\n    while (!stack.empty && getColor(x) == RedBlackEnum.black) {\n        parent = stack.peek();\n        y = getChild(parent, siblingComparer(comp));\n        if (comp < 0) {\n            //x is left child, y is right child\n            if (getColor(y) == RedBlackEnum.red) {\n                // x is black, y is red - make both black and rotate\n                y.color = RedBlackEnum.black;\n                parent.color = RedBlackEnum.red;\n                stack.pop();\n                rotateLeft(parent, tree, stack, true);\n                stack.push(parent);\n                y = parent.right;\n            }\n            if (y == undefined ||\n                (getColor(y.left) == RedBlackEnum.black &&\n                    getColor(y.right) == RedBlackEnum.black)) {\n                //y children are both black or y is a leaf\n                (y != undefined) && (y.color = RedBlackEnum.red);\n                //move up\n                stack.pop();\n                x = parent;\n                parent = stack.peek();\n                (parent != undefined) && (comp = tree.comparer(x.value, parent.value));\n            }\n            else {\n                if (getColor(y.right) == RedBlackEnum.black) {\n                    y.left.color = RedBlackEnum.black;\n                    y.color = RedBlackEnum.red;\n                    rotateRight(y, tree, stack, false);\n                    y = getChild(parent, 1);\n                }\n                y.color = parent.color; // x.parent.color\n                parent.color = RedBlackEnum.black;\n                y.right.color = RedBlackEnum.black;\n                stack.pop();\n                rotateLeft(parent, tree, stack, false);\n                stack.clear();\n                return;\n            }\n        }\n        else {\n            //y is left child, x is right child\n            //y could be null\n            if (getColor(y) == RedBlackEnum.red) {\n                // x is black, y is red - make both black and rotate\n                y.color = RedBlackEnum.black;\n                parent.color = RedBlackEnum.red;\n                stack.pop();\n                rotateRight(parent, tree, stack, true);\n                stack.push(parent);\n                y = parent.left;\n            }\n            if (y == undefined ||\n                (getColor(y.left) == RedBlackEnum.black &&\n                    getColor(y.right) == RedBlackEnum.black)) {\n                //y children are both black or y is a leaf\n                (y != undefined) && (y.color = RedBlackEnum.red);\n                //move up\n                stack.pop();\n                x = parent;\n                parent = stack.peek();\n                (parent != undefined) && (comp = tree.comparer(x.value, parent.value));\n            }\n            else {\n                if (getColor(y.left) == RedBlackEnum.black) {\n                    y.right.color = RedBlackEnum.black;\n                    y.color = RedBlackEnum.red;\n                    rotateLeft(y, tree, stack, false);\n                    y = getChild(parent, -1);\n                }\n                y.color = parent.color; // x.parent.color\n                parent.color = RedBlackEnum.black;\n                y.left.color = RedBlackEnum.black;\n                stack.pop();\n                rotateRight(parent, tree, stack, false);\n                stack.clear();\n                return;\n            }\n        }\n    }\n    (x != undefined) && (x.color = RedBlackEnum.black);\n}\n\n\n//# sourceURL=webpack://adtjs/./src/lib/RedBlackTree.ts?\n}");

/***/ }),

/***/ "./src/lib/Stack.ts":
/*!**************************!*\
  !*** ./src/lib/Stack.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Stack: () => (/* binding */ Stack)\n/* harmony export */ });\nclass Stack {\n    constructor() {\n        this.clear();\n    }\n    get count() { return this.n.length; }\n    get last() { return this.n.length - 1; }\n    get items() { return this.n.slice(0); }\n    get empty() { return !this.n.length; }\n    pop() { return this.n.pop(); }\n    push(t) { return this.n.push(t); }\n    peek() { return this.n[this.last]; }\n    clear() { this.n = new Array(); }\n    static from(initialData = []) {\n        const s = new Stack();\n        s.n.push(...initialData);\n        return s;\n    }\n}\n\n\n//# sourceURL=webpack://adtjs/./src/lib/Stack.ts?\n}");

/***/ }),

/***/ "./src/lib/Tree.ts":
/*!*************************!*\
  !*** ./src/lib/Tree.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseTree: () => (/* binding */ BaseTree),\n/* harmony export */   Tree: () => (/* binding */ Tree),\n/* harmony export */   TreeNode: () => (/* binding */ TreeNode),\n/* harmony export */   ValueNode: () => (/* binding */ ValueNode)\n/* harmony export */ });\n/* harmony import */ var _Queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Queue */ \"./src/lib/Queue.ts\");\n/* harmony import */ var _Stack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Stack */ \"./src/lib/Stack.ts\");\n\n\nclass ValueNode {\n    constructor(value) {\n        this.value = value;\n    }\n    /**\n     * @description return the amount of children\n     */\n    get length() { return this.children.length; }\n    /**\n     * @description children indexer\n     * @param index 0-based index of child\n     */\n    get(index) { return this.children[index]; }\n}\nclass TreeNode extends ValueNode {\n    get children() { return this.__children.slice(0); }\n    get size() { return this.__children.length; }\n    get isLeaf() { return this.size == 0; }\n    constructor(value, ...childrenNodes) {\n        super(value);\n        this.__children = new Array(...childrenNodes);\n    }\n    add(value) {\n        let n = new TreeNode(value);\n        this.__children.push(n);\n        return n;\n    }\n    remove(value, comparer) {\n        let defaultComparer = (item) => item.value === value, n = this.__children.findIndex(comparer || defaultComparer);\n        return n != -1 ? this.__children.splice(n, 1)[0] : undefined;\n    }\n    removeAt(index) {\n        return index >= 0 && index < this.size ? this.__children.splice(index, 1)[0] : undefined;\n    }\n    find(value, comparer) {\n        let defaultComparer = (item) => item.value === value;\n        return this.__children.find(comparer || defaultComparer);\n    }\n}\nclass BaseTree {\n    constructor(comparer) {\n        this.__comp = comparer || compare;\n    }\n    empty() { return this.root == undefined; }\n    clear() {\n        this.root = void 0;\n    }\n    get comparer() { return this.__comp; }\n    /**\n     * @description it calls levelOrder from root, and returns it's result with empty callback.\n     */\n    depth() {\n        let result, enumerator = this.levelOrderEnumerator();\n        while (!(result = enumerator.next()).done)\n            ;\n        return result.value;\n    }\n    *preOrderEnumerator(node) {\n        let stack = new _Stack__WEBPACK_IMPORTED_MODULE_1__.Stack(), count = 0;\n        !node && (node = this.root);\n        if (node) {\n            stack.push(node);\n            while (!stack.empty) {\n                count++;\n                node = stack.pop();\n                yield node;\n                for (let children = node.children, i = children.length - 1; i >= 0; i--) {\n                    stack.push(children[i]);\n                }\n            }\n        }\n        return count;\n    }\n    preOrderIterator(node) {\n        let enumerator = this.preOrderEnumerator(node), iterator = {\n            //Iterator protocol\n            next: () => {\n                return enumerator.next();\n            },\n            //Iterable protocol\n            [Symbol.iterator]() {\n                return iterator;\n            }\n        };\n        return iterator;\n    }\n    /**\n     * @description it's an extended breadthSearch with a tree node level value\n     * @param node root node to calculate level order\n     * @param callback a function called for every tree node with it's level 1-based\n     */\n    *levelOrderEnumerator(node) {\n        let queue = new _Queue__WEBPACK_IMPORTED_MODULE_0__.Queue(), maxLevel = 0;\n        !node && (node = this.root);\n        if (node) {\n            queue.enqueue({ node: node, level: 1 });\n            while (!queue.empty) {\n                let father = queue.dequeue();\n                maxLevel = Math.max(maxLevel, father.level);\n                yield {\n                    node: father.node,\n                    level: father.level\n                };\n                father.node.children.forEach((child) => queue.enqueue({ node: child, level: father.level + 1 }));\n            }\n        }\n        return maxLevel;\n    }\n    *postOrderEnumerator(node) {\n        let stack = new _Stack__WEBPACK_IMPORTED_MODULE_1__.Stack(), count = 0;\n        !node && (node = this.root);\n        if (node) {\n            stack.push({ node: node, t: false });\n            while (!stack.empty) {\n                let n = stack.peek();\n                if (n.t) {\n                    count++;\n                    yield n.node;\n                    stack.pop();\n                }\n                else {\n                    n.t = true;\n                    for (let children = n.node.children, i = children.length - 1; i >= 0; i--) {\n                        stack.push({ node: children[i], t: false });\n                    }\n                }\n            }\n        }\n        return count;\n    }\n    *breathSearchEnumerator(node) {\n        let queue = new _Queue__WEBPACK_IMPORTED_MODULE_0__.Queue(), count = 0;\n        !node && (node = this.root);\n        if (node) {\n            queue.enqueue(node);\n            while (!queue.empty) {\n                node = queue.dequeue();\n                count++;\n                yield node;\n                node.children.forEach(child => queue.enqueue(child));\n            }\n        }\n        return count;\n    }\n}\nclass Tree extends BaseTree {\n    /**\n     * @description implements a breadth search\n     * @param value value to search\n     */\n    find(value) {\n        let queue = new _Queue__WEBPACK_IMPORTED_MODULE_0__.Queue(), node = this.root;\n        if (node) {\n            queue.enqueue(node);\n            while (!queue.empty) {\n                node = queue.dequeue();\n                if (this.comparer(node.value, value) == 0) {\n                    queue.clear();\n                    return node;\n                }\n                else {\n                    node.children.forEach(child => queue.enqueue(child));\n                }\n            }\n        }\n    }\n    constructor(root, comparer) {\n        super(comparer);\n        this.root = root;\n    }\n}\nfunction compare(a, b) {\n    if (a == b)\n        return 0;\n    else if (a > b)\n        return 1;\n    else\n        return -1;\n}\n\n\n//# sourceURL=webpack://adtjs/./src/lib/Tree.ts?\n}");

/***/ }),

/***/ "./src/lib/Utils.ts":
/*!**************************!*\
  !*** ./src/lib/Utils.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   centerPadStr: () => (/* binding */ centerPadStr),\n/* harmony export */   centerStr: () => (/* binding */ centerStr),\n/* harmony export */   enumConditional: () => (/* binding */ enumConditional),\n/* harmony export */   matrix: () => (/* binding */ matrix),\n/* harmony export */   replaceAt: () => (/* binding */ replaceAt),\n/* harmony export */   svg: () => (/* binding */ svg),\n/* harmony export */   tag: () => (/* binding */ tag)\n/* harmony export */ });\n/* harmony import */ var dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dabbjs/dist/lib/dom */ \"./node_modules/.pnpm/dabbjs@0.0.29/node_modules/dabbjs/dist/lib/dom.js\");\n/* harmony import */ var dabbjs_dist_lib_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dabbjs/dist/lib/strings */ \"./node_modules/.pnpm/dabbjs@0.0.29/node_modules/dabbjs/dist/lib/strings.js\");\n\n\nconst svgNS = \"http://www.w3.org/2000/svg\";\n//used for string & numbers\n// export const pad = (t: string, e: number, ch?: any) =>\n// \tnew Array(Math.max(0, (e || 2) + 1 - String(t).length)).join(ch || '0') + t;\n// export const fillChar = (ch: string, len: number) => new Array(len).join(ch);\n// export const padStr = (s: string, width: number) => new Array(Math.max(0, width - s.length)).join(' ') + s;\n// export const formatNumber = (n: number, width: number) => padStr(n + \"\", width);\nconst centerStr = (s, width) => {\n    let w = (width - s.length) / 2 | 0;\n    return ((0,dabbjs_dist_lib_strings__WEBPACK_IMPORTED_MODULE_1__.fillChar)(' ', w + 1) + s + (0,dabbjs_dist_lib_strings__WEBPACK_IMPORTED_MODULE_1__.fillChar)(' ', w + 1)).substring(0, width);\n};\nconst centerPadStr = (str, width, leftStr, rightStr) => {\n    let w = (width - str.length) / 2 | 0, getChar = (s) => (s && (s = s[0]), s || ' ');\n    return ((0,dabbjs_dist_lib_strings__WEBPACK_IMPORTED_MODULE_1__.fillChar)(getChar(leftStr), w + 1) + str + (0,dabbjs_dist_lib_strings__WEBPACK_IMPORTED_MODULE_1__.fillChar)(getChar(rightStr), w + 1)).substring(0, width);\n};\nconst replaceAt = (str, index, replacement) => str.substring(0, index) + replacement + str.substring(index + replacement.length);\nconst matrix = (rows, cols, filler) => Array.from({ length: rows }, () => new Array(cols).fill(filler));\nconst enumConditional = (start, max, discovered) => {\n    let nextNdx = (ndx) => ndx >= max ? 0 : ++ndx, curr = start < 0 || start > max ? -1 : start, first = true;\n    return {\n        current: () => curr,\n        next: () => {\n            if (curr < 0)\n                return false;\n            if (first) {\n                return first = false, true;\n            }\n            else {\n                while (!((curr = nextNdx(curr)) == start || !discovered(curr)))\n                    ;\n                return curr != start;\n            }\n        }\n    };\n};\nconst tag = (tagName, id, nsAttrs) => (id && (nsAttrs.id = id),\n    (0,dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_0__.attr)(document.createElementNS(svgNS, tagName), nsAttrs));\nconst svg = (html) => {\n    let template = document.createElementNS(svgNS, \"template\");\n    template.innerHTML = html;\n    return template.children[0];\n};\n\n\n//# sourceURL=webpack://adtjs/./src/lib/Utils.ts?\n}");

/***/ }),

/***/ "./src/test/css/rbt.css":
/*!******************************!*\
  !*** ./src/test/css/rbt.css ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://adtjs/./src/test/css/rbt.css?\n}");

/***/ }),

/***/ "./src/test/rbt.ts":
/*!*************************!*\
  !*** ./src/test/rbt.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_RedBlackTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/RedBlackTree */ \"./src/lib/RedBlackTree.ts\");\n/* harmony import */ var _tree_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tree-utils */ \"./src/test/tree-utils.ts\");\n/* harmony import */ var dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! dabbjs/dist/lib/dom */ \"./node_modules/.pnpm/dabbjs@0.0.29/node_modules/dabbjs/dist/lib/dom.js\");\n\n\n\nlet ratio = window.screen.width / window.screen.height, svg = document.querySelector('svg'), vbinfo = (0,dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_2__.qS)(\"#canvas-info\"), node = (0,dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_2__.qS)(\"#node-value\"), cons = (0,dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_2__.qS)(\"#cons-out>div:nth-of-type(2)\"), treeSize = (0,dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_2__.qS)(\"#tree-size\"), leftpad = 20, toppad = 40, xstart = leftpad, ystart = toppad, rowHeight = ystart, viewbox = setViewBox(0, 0, svg.clientWidth * ratio | 0, svg.clientHeight * ratio | 0), options = void 0, svgRowItems = [], maxYcaption = Number.MIN_SAFE_INTEGER;\nclearSVG(createTree());\n(0,dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_2__.aEL)((0,dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_2__.qS)(\"#clear-tree\"), \"click\", () => {\n    clearSVG(createTree());\n}, false);\n(0,dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_2__.aEL)((0,dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_2__.qS)(\"#load-sample\"), \"click\", (e) => {\n    clearSVG(getTreeSample());\n    addSVGTree(\"sample tree\");\n}, false);\n(0,dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_2__.aEL)((0,dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_2__.qS)(\"#insert\"), \"click\", (e) => {\n    let nodeValue = getNodeValue(), value = parseFloat(nodeValue);\n    if (isNaN(value)) {\n        logMsg(`invalid number: ${nodeValue}`);\n    }\n    else {\n        if (options.tree.insert(createNode(value))) {\n            addSVGTree(`added: ${value}`);\n        }\n        else {\n            logMsg(`could not insert: ${nodeValue}`);\n        }\n    }\n}, false);\n(0,dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_2__.aEL)((0,dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_2__.qS)(\"#delete\"), \"click\", (e) => {\n    let nodeValue = getNodeValue(), value = parseFloat(nodeValue);\n    if (isNaN(value)) {\n        logMsg(`invalid number: ${nodeValue}`);\n    }\n    else {\n        if (options.tree.delete(createNode(value))) {\n            addSVGTree(`deleted: ${value}`);\n        }\n        else {\n            logMsg(`could not insert: ${nodeValue}`);\n        }\n    }\n}, false);\nfunction setViewBox(x, y, w, h) {\n    (0,dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_2__.attr)(svg, { \"viewBox\": `${x} ${y} ${w} ${h}` });\n    vbinfo.innerText = `x: ${x}, y: ${y}, width: ${w}, height: ${h}`;\n    return {\n        x: x,\n        y: y,\n        width: w,\n        height: h\n    };\n}\nfunction createTree() {\n    return new _lib_RedBlackTree__WEBPACK_IMPORTED_MODULE_0__.RedBlackTree((a, b) => {\n        if (a.value == b.value)\n            return 0;\n        else if (a.value > b.value)\n            return 1;\n        else\n            return -1;\n    });\n}\nfunction createNode(value) {\n    return {\n        value: value\n    };\n}\nfunction getTreeSample() {\n    let t = createTree(), array = [7, 3, 18, 10, 22, 8, 11, 26, 2, 6, 13].map(v => createNode(v));\n    t.insertRange(array);\n    return t;\n}\nfunction getNodeValue() {\n    let nodeValue = node.value;\n    node.value = \"\";\n    return nodeValue;\n}\nfunction getTreeSizeLabel() {\n    return `Size: ${options.tree.size}`;\n}\nfunction clearSVG(tree) {\n    svg.innerHTML = \"\";\n    leftpad = 20;\n    toppad = 40;\n    xstart = leftpad;\n    ystart = toppad;\n    rowHeight = ystart;\n    options = {\n        svg: svg,\n        tree: tree,\n        caption: \"[caption]\",\n        WIDTH: 40,\n        HEIGHT: 60,\n        FONT_SIZE: 20,\n        x: 0,\n        y: 0,\n        nodeClass: (node) => _lib_RedBlackTree__WEBPACK_IMPORTED_MODULE_0__.RedBlackEnum[node.color],\n        nodeValue: (node) => String(node.value)\n    };\n    cons.innerHTML = \"\";\n    treeSize.innerText = getTreeSizeLabel();\n    svgRowItems = [];\n}\nfunction logMsg(msg) {\n    cons.appendChild((0,dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_2__.html)(`<div>${msg}</div>`));\n}\nfunction addSVGTree(caption) {\n    treeSize.innerText = getTreeSizeLabel();\n    options.caption = caption;\n    options.x = xstart;\n    options.y = ystart;\n    let svgTree = (0,_tree_utils__WEBPACK_IMPORTED_MODULE_1__.BTreeVisualizer)(options);\n    rowHeight = Math.max(rowHeight, svgTree.height);\n    if (svgTree.width + xstart > viewbox.width) {\n        moveToNextRow();\n        svgTree.svg.setAttribute(\"transform\", `translate(${xstart} ${ystart})`);\n        svgRowItems = [svgTree.svg];\n        maxYcaption = svgTree.height;\n    }\n    else {\n        svgRowItems.push(svgTree.svg);\n        maxYcaption = Math.max(maxYcaption, svgTree.height);\n        //adjust g>text\n        svgRowItems.forEach((svg) => {\n            let text = svg.querySelector(\"text.caption\");\n            (0,dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_2__.attr)(text, {\n                y: maxYcaption\n            });\n        });\n    }\n    xstart += leftpad * 2 + svgTree.width;\n}\nfunction moveToNextRow() {\n    xstart = leftpad * 2;\n    ystart += rowHeight + toppad * 2;\n    rowHeight = 0;\n}\n\n\n//# sourceURL=webpack://adtjs/./src/test/rbt.ts?\n}");

/***/ }),

/***/ "./src/test/tree-utils.ts":
/*!********************************!*\
  !*** ./src/test/tree-utils.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BTreeVisualizer: () => (/* binding */ BTreeVisualizer)\n/* harmony export */ });\n/* harmony import */ var dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dabbjs/dist/lib/dom */ \"./node_modules/.pnpm/dabbjs@0.0.29/node_modules/dabbjs/dist/lib/dom.js\");\n/* harmony import */ var _lib_Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/Utils */ \"./src/lib/Utils.ts\");\n\n\n;\nfunction BTreeVisualizer(conf) {\n    let depth = 0, width = 0, height = 0, svgTree = (0,_lib_Utils__WEBPACK_IMPORTED_MODULE_1__.tag)(\"g\", \"\", {\n        class: \"svg-tree\",\n        transform: `translate(${conf.x | 0} ${conf.y | 0})`\n    }), svgCaption = (0,_lib_Utils__WEBPACK_IMPORTED_MODULE_1__.tag)(\"text\", \"\", {\n        class: \"caption\",\n        \"font-size\": conf.FONT_SIZE,\n    });\n    if (conf && conf.tree && conf.svg) {\n        conf.svg.appendChild(svgTree);\n        depth = conf.tree.depth();\n        width = depth == 1 ? 1 : Math.pow(2, depth - 1);\n        width = width * conf.WIDTH;\n        height = visualizeNode(conf.tree.root, svgTree, 0, width, 0, conf);\n        svgCaption.innerHTML = conf.caption || \"[caption]\";\n        svgTree.appendChild(svgCaption);\n        let box = svgCaption.getBBox();\n        (0,dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_0__.attr)(svgCaption, {\n            x: Math.max(0, (width / 2 - box.width / 2) | 0),\n            y: height\n        });\n        box = svgTree.getBBox();\n        width = box.width;\n        height = box.height;\n    }\n    return {\n        svg: svgTree,\n        width: width,\n        height: height\n    };\n}\nfunction visualizeNode(node, svg, minx, maxx, y, conf) {\n    if (node == undefined)\n        return 0;\n    let halfWidth = conf.WIDTH / 2 | 0, centerX = minx + (maxx - minx) / 2 | 0, centerY = y + halfWidth, circleRadius = conf.WIDTH / 2 | 0, cl = conf.nodeClass ? conf.nodeClass(node) : \"\", nextYStart = y + conf.HEIGHT, svgNodeX = centerX - circleRadius, svgNodeY = centerY - circleRadius, svgNode = (0,_lib_Utils__WEBPACK_IMPORTED_MODULE_1__.tag)(\"g\", \"\", {\n        class: \"svg-node \" + cl,\n        transform: `translate(${svgNodeX} ${svgNodeY})`\n    }), svgCircle = (0,_lib_Utils__WEBPACK_IMPORTED_MODULE_1__.tag)(\"circle\", \"\", {\n        cx: circleRadius,\n        cy: circleRadius,\n        r: circleRadius\n    }), svgText = (0,_lib_Utils__WEBPACK_IMPORTED_MODULE_1__.tag)(\"text\", \"\", {\n        \"font-size\": conf.FONT_SIZE,\n        class: \"no-select\"\n    });\n    svgText.innerHTML = conf.nodeValue(node.value);\n    svgNode.appendChild(svgCircle);\n    svgNode.appendChild(svgText);\n    svg.appendChild(svgNode);\n    if (!node.isLeaf) {\n        let childrenY = nextYStart + halfWidth, childrenX = 0;\n        if (node.left) {\n            childrenX = minx + (centerX - minx) / 2 | 0;\n            svg.appendChild((0,_lib_Utils__WEBPACK_IMPORTED_MODULE_1__.tag)(\"line\", \"\", lineAttrs(centerX, centerY, childrenX, childrenY, circleRadius)));\n        }\n        if (node.right) {\n            childrenX = centerX + (maxx - centerX) / 2 | 0;\n            svg.appendChild((0,_lib_Utils__WEBPACK_IMPORTED_MODULE_1__.tag)(\"line\", \"\", lineAttrs(centerX, centerY, childrenX, childrenY, circleRadius)));\n        }\n    }\n    let box = svgText.getBBox();\n    (0,dabbjs_dist_lib_dom__WEBPACK_IMPORTED_MODULE_0__.attr)(svgText, {\n        x: circleRadius - box.width / 2 | 0,\n        y: circleRadius + box.height / 4 | 0\n    });\n    return Math.max(nextYStart, visualizeNode(node.left, svg, minx, centerX, nextYStart, conf), visualizeNode(node.right, svg, centerX, maxx, nextYStart, conf));\n}\nfunction lineAttrs(x1, y1, x2, y2, r) {\n    let angle = Math.atan2(y1 - y2, x1 - x2);\n    x1 = (x1 - r * Math.cos(angle)) | 0;\n    y1 = (y1 - r * Math.sin(angle)) | 0;\n    x2 = (x2 + r * Math.cos(angle)) | 0;\n    y2 = (y2 + r * Math.sin(angle)) | 0;\n    return {\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        class: \"svg-line\"\n    };\n}\n\n\n//# sourceURL=webpack://adtjs/./src/test/tree-utils.ts?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	__webpack_require__("./src/test/rbt.ts");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/test/css/rbt.css");
/******/ 	
/******/ })()
;